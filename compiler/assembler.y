%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <stdbool.h>

#include "hashtable.h"

int yylex(void);
void yyerror(char *);

extern int yyline; 
extern FILE *yyin;
extern char yyname[256];

struct instruction_fields {
	unsigned int imm : 16;
	unsigned int rd : 4;
	unsigned int rs : 4;
	unsigned int opcode : 6;
	unsigned int prefix : 2;
};

union encode_instruction {
	unsigned int data;
	struct instruction_fields f;
};

struct prefix {
	unsigned char dst;
	unsigned char src;
};

union encode_prefix {
	unsigned char data;
	struct prefix p;
};

struct code {
	bool has_reference;
	unsigned int index;
	unsigned int instruction;
	char symbol[256];
	struct code *next;
};

bool is_labeled = false;	/* instruction contains label? */
struct code *tail = NULL;	/* last generated entry */
struct code *gen_code = NULL;	/* code generated by assembler */

void debug_instruction();
void generate_instruction();
void insert_new_label();
void derefer_label();

struct hash_table *symbols;

unsigned int text[256] = {0};
int current = 0;
union encode_instruction instr;
union encode_prefix pfix;

%}

%token CONST
%token LABEL

%token REGISTER

%token OPCODE_BINARY
%token OPCODE_UNARY		 
%token OPCODE_SINGLE		/* halt, nop */
%token HALT
%token NOP
%token OUTW

%%
program: 
       program binary { generate_instruction(); }
       | program unary { generate_instruction(); }
       | program single { generate_instruction(); }
       | program LABEL ':'  { insert_new_label(); }
       |
       ;


binary:
    OPCODE_BINARY src ',' dst { instr.f.opcode = $1; }
    ;

unary:
     OPCODE_UNARY src { instr.f.opcode = $1; }
     | OPCODE_UNARY LABEL { instr.f.opcode = $1; pfix.data = 3; is_labeled = true; }
     ;
	
single:
      OPCODE_SINGLE { instr.f.opcode = $1; }
      ;

src:
   REGISTER     { pfix.p.src  = 0; instr.f.rs  = $1; }
   | '$' CONST	{ pfix.data = 3; instr.f.imm = $2; }   /* constant integer */
//   | '&' CONST  { pfix.p.src  = 1; instr.f.imm = $2; } /* memory address */
   | '&' '('LABEL')' { pfix.p.src = 1; is_labeled = true; }
   ;

dst:
   REGISTER     { 
			instr.f.rd = $1;
			if (pfix.data != 3)
				pfix.p.dst = 0;
		}

   | '&' '(' LABEL ')' { 
			if (pfix.data == 3) {
				char err[256] = "\0"; 
				sprintf(err, 
					"Syntax error! Illegal combination of "
					"source and destination "
					"on the line: %d\n", yyline);
				yyerror(err);
				return -1;
			} else {
				pfix.p.dst = 1;
//				instr.f.imm = $2;
				is_labeled = true;
			}
		}
   ;

%%

void debug_instruction()
{
	printf("prefix: %d\n", pfix.data); 
	printf("opcode: %d\n", instr.f.opcode);
	printf("rs: %d\n", instr.f.rs);
	printf("rd: %d\n", instr.f.rd);
	printf("imm: %d\n", instr.f.imm);
	printf("%x\n", instr.data);
}

struct code *new_slot(bool has_reference, char *label)
{
	struct code *c = (struct code *) malloc(sizeof(*c));
	if (!c)
		return NULL;

	instr.f.prefix = pfix.data;
	c->has_reference = has_reference;
	c->instruction = instr.data; 
	c->index = current;
	if (has_reference)
		strncpy(c->symbol, label, 256);

	current++;

	return c;
}

void generate_instruction()
{
	debug_instruction();
	if (tail == NULL) {
		gen_code = new_slot(is_labeled, yyname);
		tail = gen_code;
	} else {
		tail->next = new_slot(is_labeled, yyname);
		tail = tail->next;
	}

	if (is_labeled)
		memset(yyname, '\0', 256);

	is_labeled = false;
	pfix.data = 0;
	instr.data = 0;
}

void insert_new_label()
{
	int retval = ht_insert(symbols, yyname, current);
	if (retval < 0) {
		char err[256];
		sprintf(err, "Error! Label \"%s\" already defined in section .text: %d\n",
				yyname, ht_get(symbols, yyname));
		yyerror(err);
		exit(-1);
	}
	pfix.data = 0;
	memset(yyname, '\0', 256);
}

void link()
{
	struct code *head = gen_code;
	union encode_instruction ei; 
	int refval;			/* memory location of reference */
	if (!head)
		return;
	
	while(head) {
		ei.data = head->instruction;
		if (head->has_reference) {
			refval = ht_get(symbols, head->symbol);
			if (refval < 0) {
				fprintf(stderr, "Linker error! "
					"Undefined reference to %s in "
					"section .text at %d\n", head->symbol, head->index);
				exit(-1);
			}

			ei.f.imm = (unsigned int)refval;
		} 
		text[head->index] = ei.data;
		head = head->next;
	}
}

int main(int argc, char *argv[])
{
	FILE *f_out = NULL;
	yyin = fopen(argv[1], "r");

	if (argc > 2) {
		if(!strcmp("-o", argv[2] ) && argc > 3)
			f_out = fopen(argv[3], "wb");
		else {
			fprintf(stderr, "Usage: as <input file> -o <output_file>");
			exit(-1);
		}
	}

	symbols= ht_create(999);
	yyparse();
	
	link();

	if (!f_out)
		f_out = fopen("raw.out", "wb");
	fwrite(text, current , sizeof(unsigned int), f_out);
	fclose(yyin);
	fclose(f_out);
	return 0;
}
