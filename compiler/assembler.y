%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <stdbool.h>

#include "hashtable.h"
//#define DEBUG_INSTRUCTION
int yylex(void);
void yyerror(char *);

extern int yyline; 
extern FILE *yyin;
extern char yyname[256];

struct instruction_fields {
	int imm : 16;
	unsigned int rd : 4;
	unsigned int rs : 4;
	unsigned int opcode : 6;
	unsigned int prefix : 2;
};

union encode_instruction {
	unsigned int data;
	struct instruction_fields f;
};

struct prefix {
	unsigned char dst;
	unsigned char src;
};

union encode_prefix {
	unsigned char data;
	struct prefix p;
};

struct code {
	bool has_reference;
	unsigned int index;
	unsigned int instruction;
	char symbol[256];
	struct code *next;
};

bool is_labeled = false;	/* instruction contains label? */
struct code *tail = NULL;	/* last generated entry */
struct code *gen_code = NULL;	/* code generated by assembler */

void debug_instruction();
void generate_instruction();
void insert_new_label();
void derefer_label();

struct hash_table *symbols;

unsigned int text[256] = {0};
int current = 0;
union encode_instruction instr;
union encode_prefix pfix;

%}

%token CONST
%token LABEL

%token REGISTER
%token OPCODE_NOP
%token OPCODE_MEM_RD
%token OPCODE_MEM_WR
%token OPCODE_ALU
%token OPCODE_HLT
%token OPCODE_IO

%%
program: 
       program alu{ generate_instruction(); }
       | program mem_rd { generate_instruction(); }
       | program mem_wr { generate_instruction(); }
       | program io { generate_instruction(); }
       | program halt { generate_instruction(); }
       | program nop { generate_instruction(); }
       | program LABEL ':'  { insert_new_label(); }
       |
       ;


halt:
    OPCODE_HLT 
	{ 
		instr.f.opcode = $1; 
	}
	;
nop:
   OPCODE_NOP
	{
		pfix.data = 0;
	}
	;
/* io instructions are just just for emulator. DO NOT USE THEM ON HARDWARE (not * implemented) */
io:
  OPCODE_IO '%'src_reg
	{
		pfix.data = 0;
		instr.f.opcode = $1;
	}
	;
alu:
   OPCODE_ALU '%'src_reg',' '%'dst_reg
	{ 
		pfix.data = 0;
		instr.f.opcode = $1; 
	}
   | OPCODE_ALU '$'imm ',' '%'dst_reg
	{
		pfix.data = 3;
		instr.f.opcode = $1;
	}
   | OPCODE_ALU '$'LABEL ',' '%'dst_reg
	{
		pfix.data = 0;
		instr.f.opcode = $1;
		is_labeled = true;
	}
   ;

mem_rd:
      OPCODE_MEM_RD '('LABEL')'',' '%'dst_reg
	{
		pfix.data = 2;
		instr.f.opcode = $1;
	}
      | OPCODE_MEM_RD '('imm')' ',' '%'dst_reg
	{
		pfix.data = 2;
		instr.f.opcode = $1;
	}
      ;

mem_wr:
      OPCODE_MEM_WR '%'src_reg ',' '('LABEL')'
	{
		pfix.data = 1;
		instr.f.opcode = $2;
		is_labeled = true;
	}
      | OPCODE_MEM_WR '%'src_reg',' '('imm')'
        {
		pfix.data = 1;
		instr.f.opcode = $1;
	}
      ;

imm:
   CONST {instr.f.imm = $1; }
   ;
   
src_reg:
       REGISTER { instr.f.rs = $1; }
       ;
dst_reg:
       REGISTER { instr.f.rd = $1; }
       ;
%%

void debug_instruction()
{
	printf("prefix: %d\n", pfix.data); 
	printf("opcode: %d\n", instr.f.opcode);
	printf("rs: %d\n", instr.f.rs);
	printf("rd: %d\n", instr.f.rd);
	printf("imm: %d\n", instr.f.imm);
	printf("%x\n", instr.data);
}

struct code *new_slot(bool has_reference, char *label)
{
	struct code *c = (struct code *) malloc(sizeof(*c));
	if (!c)
		return NULL;

	instr.f.prefix = pfix.data;
	c->has_reference = has_reference;
	c->instruction = instr.data; 
	c->index = current;
	if (has_reference)
		strncpy(c->symbol, label, 256);

	current++;

	return c;
}

void generate_instruction()
{
#ifdef DEBUG_INSTRUCTION
	debug_instruction();
#endif
	if (tail == NULL) {
		gen_code = new_slot(is_labeled, yyname);
		tail = gen_code;
	} else {
		tail->next = new_slot(is_labeled, yyname);
		tail = tail->next;
	}

	if (is_labeled)
		memset(yyname, '\0', 256);

	is_labeled = false;
	pfix.data = 0;
	instr.data = 0;
}

void insert_new_label()
{
	int retval = ht_insert(symbols, yyname, current);
	if (retval < 0) {
		char err[256];
		sprintf(err, "Error! Label \"%s\" already defined in section .text: %d\n",
				yyname, ht_get(symbols, yyname));
		yyerror(err);
		exit(-1);
	}
	pfix.data = 0;
	memset(yyname, '\0', 256);
}

void link()
{
	struct code *head = gen_code;
	union encode_instruction ei; 
	int refval;			/* memory location of reference */
	if (!head)
		return;
	
	while(head) {
		ei.data = head->instruction;
		if (head->has_reference) {
			refval = ht_get(symbols, head->symbol);
			if (refval < 0) {
				fprintf(stderr, "Linker error! "
					"Undefined reference to %s in "
					"section .text at %d\n", head->symbol, head->index);
				exit(-1);
			}

			ei.f.imm = (unsigned int)refval;
		} 
		text[head->index] = ei.data;
		head = head->next;
	}
}

int main(int argc, char *argv[])
{
	FILE *f_out = NULL;
	yyin = fopen(argv[1], "r");

	if (argc > 2) {
		if(!strcmp("-o", argv[2] ) && argc > 3)
			f_out = fopen(argv[3], "wb");
		else {
			fprintf(stderr, "Usage: as <input file> -o <output_file>");
			exit(-1);
		}
	}

	symbols= ht_create(999);
	yyparse();
	
	link();

	if (!f_out)
		f_out = fopen("raw.out", "wb");
	fwrite(text, current , sizeof(unsigned int), f_out);
	fclose(yyin);
	fclose(f_out);
	return 0;
}
